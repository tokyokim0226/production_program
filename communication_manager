from PyQt5.QtCore import QThread, QDateTime, QTimer
from serial_reader_worker import SerialReaderWorker
from protocol_handler import ProtocolHandler
from PyQt5.QtWidgets import QMessageBox

class CommunicationManager:
    def __init__(self, parent):
        self.parent = parent
        self.serial_port = self.parent.connection_manager.serial_port
        self.protocol_handler = ProtocolHandler(self.parent)

        self.reading_thread = None
        self.worker = None

        self.buffer_timer = QTimer()
        self.buffer_timeout = 500  # Set the buffer flush timeout to 500ms
        self.buffer_timer.timeout.connect(self.flush_worker_buffer)

    def start_reading_thread(self):
        self.reading_thread = QThread()  # Create a new thread
        self.worker = SerialReaderWorker(self.serial_port)  # Create a worker instance for the thread
        self.worker.moveToThread(self.reading_thread)  # Move the worker to the thread

        self.reading_thread.started.connect(self.worker.run)  # Connect thread started signal to worker run method
        self.worker.message_received.connect(self.handle_received_message_with_time)  # Connect worker message_received signal to handler
        self.worker.data_received.connect(self.reset_buffer_timer)  # Reset the buffer timer when new data is received
        self.worker.error_occurred.connect(self.protocol_handler.handle_error)  # Connect worker error_occurred signal to handler
        self.worker.finished.connect(self.reading_thread.quit)  # Connect worker finished signal to thread quit
        self.worker.finished.connect(self.worker.deleteLater)  # Ensure worker is deleted when finished
        self.reading_thread.finished.connect(self.reading_thread.deleteLater)  # Ensure thread is deleted when finished

        self.reading_thread.start()  # Start the thread

    def stop_reading_thread(self):
        if self.worker:
            self.worker.running = False
            if self.reading_thread:
                self.reading_thread.quit()
                self.reading_thread.wait()
            self.worker = None
        if self.reading_thread:
            self.reading_thread = None

    def send_message(self, message):
        if self.serial_port and self.serial_port.is_open:
            try:
                start_time = QDateTime.currentDateTime()
                if self.protocol_handler.validate_message(message):
                    self.serial_port.write(message.encode('utf-8'))
                    end_time = QDateTime.currentDateTime()
                    elapsed_time = start_time.msecsTo(end_time)
                    self.parent.logger.log_message("Sent", message.strip(), f"{elapsed_time} ms")
                else:
                    QMessageBox.warning(self.parent, "Invalid Input", "Message format is invalid")
            except Exception as e:
                self.parent.logger.log_message("Error", str(e))
        else:
            QMessageBox.warning(self.parent, "Not Connected", "Please select a COM port.")

    def send_generated_message(self):
        message = self.parent.message_display.text()
        self.send_message(message)

    def handle_received_message_with_time(self, message, time_taken):
        """Handle received messages and display the time taken."""
        self.parent.logger.log_message("Received", message.strip(), f"{time_taken} ms")

    def reset_buffer_timer(self):
        """Reset or start the buffer timer when new data is received."""
        self.buffer_timer.start(self.buffer_timeout)

    def flush_worker_buffer(self):
        """Flush the buffer in the worker and print its content if no ETX character is found within the timeout."""
        if self.worker:
            self.worker.flush_buffer()
